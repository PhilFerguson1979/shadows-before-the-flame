---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import { monsters } from '../../data/monsters';

const base = import.meta.env.BASE_URL.replace(/\/$/, '');
const characters = await getCollection('characters');

// Compact monster data for client-side search
const monsterList = monsters.map(m => ({
  n: m.name,
  s: m.slug,
  cr: m.cr,
  ac: m.ac,
  hp: m.hp,
  dex: m.dex,
  type: m.type,
}));
const sorted = characters
  .filter(c => c.data.status === 'active')
  .sort((a, b) => (a.data.name ?? '').localeCompare(b.data.name ?? ''));

const classColor: Record<string, string> = {
  'Rogue': '#c0392b',
  'Artificer': '#8e44ad',
  'Druid': '#27ae60',
  'Ranger': '#16a085',
  'Bard': '#d35400',
  'Barbarian': '#e74c3c',
  'Monk': '#2980b9',
  'Sorcerer': '#6c3483',
  'Lunar Sorcerer': '#6c3483',
};

function mod(score: number | undefined) {
  if (!score) return 0;
  return Math.floor((score - 10) / 2);
}
---

<BaseLayout title="Initiative Tracker">
  <div class="page-container">
    <div class="back-link"><a href={`${base}/dm`}>&larr; DM Tools</a></div>
    <div class="section-header">
      <h1>Initiative Tracker</h1>
    </div>
    <p class="intro-text">Roll initiative, add enemies, and track combat rounds. Fully client-side &mdash; nothing is saved.</p>

    <!-- Controls -->
    <div class="controls">
      <button id="rollAll" class="btn btn-primary">Roll All Initiative</button>
      <button id="toggleManual" class="btn btn-secondary manual-toggle">Manual Entry</button>
      <div class="monster-search-wrap">
        <input type="text" id="monsterSearch" placeholder="Search monsters..." autocomplete="off" />
        <div id="monsterSearchResults" class="monster-search-results" style="display:none;"></div>
      </div>
      <button id="addEnemy" class="btn btn-secondary">+ Custom Enemy</button>
      <button id="nextTurn" class="btn btn-accent" disabled>Next Turn</button>
      <button id="resetCombat" class="btn btn-muted">Reset</button>
      <div class="round-display">Round <span id="roundNum">0</span></div>
    </div>

    <!-- Initiative order list (populated by JS) -->
    <div id="initiativeList" class="initiative-list">
      {sorted.map(c => {
        const d = c.data;
        const color = classColor[d.class ?? ''] ?? '#8b6914';
        const dexMod = mod(d.dex);
        return (
          <div
            class="init-card"
            data-name={d.name}
            data-dex={dexMod}
            data-ac={d.ac}
            data-hp={d.maxHp}
            data-max-hp={d.maxHp}
            data-color={color}
            data-type="pc"
            data-portrait={d.portrait ? `${base}${d.portrait}` : ''}
            style={`--card-color: ${color}`}
          >
            <div class="init-roll">
              <span class="init-value">--</span>
              <span class="init-label">INIT</span>
            </div>
            {d.portrait && (
              <img class="init-portrait" src={`${base}${d.portrait}`} alt={d.name} />
            )}
            <div class="init-info">
              <div class="init-name">{d.name}</div>
              <div class="init-sub">{d.class} &bull; AC {d.ac} &bull; DEX {dexMod >= 0 ? `+${dexMod}` : dexMod}</div>
            </div>
            <div class="init-hp-block">
              <div class="init-hp-bar-wrap">
                <div class="init-hp-bar" style="width: 100%"></div>
              </div>
              <div class="init-hp-text">{d.maxHp} / {d.maxHp}</div>
            </div>
            <div class="init-actions">
              <button class="hp-btn hp-dmg" title="Click: -1 HP | Shift+Click: custom amount">-</button>
              <div class="hp-custom-input" style="display:none;">
                <input type="number" class="hp-custom-val" min="1" max="999" placeholder="#" />
                <button class="hp-custom-apply hp-custom-dmg" title="Apply damage">✓</button>
                <button class="hp-custom-apply hp-custom-heal-btn" title="Apply healing">✓</button>
              </div>
              <button class="hp-btn hp-heal" title="Click: +1 HP | Shift+Click: custom amount">+</button>
            </div>
          </div>
        );
      })}
    </div>

    <!-- Enemy template (hidden) -->
    <template id="enemyTemplate">
      <div class="init-card enemy-card" data-type="enemy" style="--card-color: #666">
        <div class="init-roll">
          <span class="init-value">--</span>
          <span class="init-label">INIT</span>
        </div>
        <div class="init-info">
          <input class="enemy-name-input" type="text" placeholder="Enemy name..." />
          <div class="enemy-fields">
            <label>AC <input type="number" class="enemy-ac" value="12" min="0" max="30" /></label>
            <label>HP <input type="number" class="enemy-hp" value="20" min="1" max="999" /></label>
            <label>DEX <input type="number" class="enemy-dex" value="0" min="-5" max="10" /></label>
            <button class="enemy-remove" title="Remove">&times;</button>
          </div>
        </div>
        <div class="init-hp-block">
          <div class="init-hp-bar-wrap">
            <div class="init-hp-bar" style="width: 100%"></div>
          </div>
          <div class="init-hp-text">20 / 20</div>
        </div>
        <div class="init-actions">
          <button class="hp-btn hp-dmg" title="Click: -1 HP | Shift+Click: custom amount">-</button>
          <div class="hp-custom-input" style="display:none;">
            <input type="number" class="hp-custom-val" min="1" max="999" placeholder="#" />
            <button class="hp-custom-apply hp-custom-dmg" title="Apply damage">✓</button>
            <button class="hp-custom-apply hp-custom-heal-btn" title="Apply healing">✓</button>
          </div>
          <button class="hp-btn hp-heal" title="Click: +1 HP | Shift+Click: custom amount">+</button>
        </div>
      </div>
    </template>
  </div>
</BaseLayout>

<script define:vars={{ monsterList }}>
  const list = document.getElementById('initiativeList');
  const rollAllBtn = document.getElementById('rollAll');
  const toggleManualBtn = document.getElementById('toggleManual');
  const addEnemyBtn = document.getElementById('addEnemy');
  const nextTurnBtn = document.getElementById('nextTurn');
  const resetBtn = document.getElementById('resetCombat');
  const roundNum = document.getElementById('roundNum');
  const template = document.getElementById('enemyTemplate');
  const monsterSearchInput = document.getElementById('monsterSearch');
  const monsterSearchResults = document.getElementById('monsterSearchResults');

  let round = 0;
  let currentIndex = -1;
  let combatStarted = false;
  let manualMode = false;
  let manualInputsShowing = false;

  function d20() { return Math.floor(Math.random() * 20) + 1; }

  function getAllCards() {
    return Array.from(list.querySelectorAll('.init-card'));
  }

  function rollInitiative(card) {
    const dex = parseInt(card.dataset.dex || '0');
    const roll = d20() + dex;
    card.dataset.init = String(roll);
    card.querySelector('.init-value').textContent = String(roll);
  }

  function sortByInitiative() {
    const cards = getAllCards();
    cards.sort((a, b) => {
      const ai = parseInt(a.dataset.init || '0');
      const bi = parseInt(b.dataset.init || '0');
      if (bi !== ai) return bi - ai;
      const ad = parseInt(a.dataset.dex || '0');
      const bd = parseInt(b.dataset.dex || '0');
      return bd - ad;
    });
    cards.forEach(card => list.appendChild(card));
  }

  function updateHP(card, delta) {
    const maxHp = parseInt(card.dataset.maxHp || '20');
    let hp = parseInt(card.dataset.hp || String(maxHp));
    hp = Math.max(0, Math.min(maxHp, hp + delta));
    card.dataset.hp = String(hp);
    const pct = Math.round((hp / maxHp) * 100);
    const bar = card.querySelector('.init-hp-bar');
    const text = card.querySelector('.init-hp-text');
    bar.style.width = pct + '%';
    bar.style.background = pct > 60 ? '#27ae60' : pct > 30 ? '#f39c12' : '#c0392b';
    text.textContent = hp + ' / ' + maxHp;
    card.classList.toggle('downed', hp === 0);
  }

  function highlightCurrent() {
    const cards = getAllCards();
    cards.forEach(c => c.classList.remove('active-turn'));
    if (currentIndex >= 0 && currentIndex < cards.length) {
      cards[currentIndex].classList.add('active-turn');
      cards[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
  }

  // Manual mode toggle
  toggleManualBtn.addEventListener('click', () => {
    manualMode = !manualMode;
    toggleManualBtn.textContent = manualMode ? 'Auto Roll' : 'Manual Entry';
    toggleManualBtn.classList.toggle('manual-active', manualMode);
    if (!manualMode && manualInputsShowing) {
      clearManualInputs();
    }
  });

  function showManualInputs() {
    manualInputsShowing = true;
    getAllCards().forEach(card => {
      const valEl = card.querySelector('.init-value');
      if (card.querySelector('.manual-init-input')) return;
      const input = document.createElement('input');
      input.type = 'number';
      input.className = 'manual-init-input';
      input.min = '1';
      input.max = '30';
      input.placeholder = '--';
      input.style.width = '40px';
      valEl.style.display = 'none';
      valEl.parentElement.insertBefore(input, valEl);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          const allInputs = Array.from(list.querySelectorAll('.manual-init-input'));
          const idx = allInputs.indexOf(input);
          if (idx < allInputs.length - 1) {
            allInputs[idx + 1].focus();
          } else {
            confirmManualRolls();
          }
        }
      });
    });
    rollAllBtn.textContent = 'Confirm Rolls';
    rollAllBtn.classList.add('btn-confirm');
    const firstInput = list.querySelector('.manual-init-input');
    if (firstInput) firstInput.focus();
  }

  function confirmManualRolls() {
    const cards = getAllCards();
    cards.forEach(card => {
      const input = card.querySelector('.manual-init-input');
      if (input) {
        const val = parseInt(input.value);
        if (!isNaN(val)) {
          card.dataset.init = String(val);
          card.querySelector('.init-value').textContent = String(val);
        } else {
          const dex = parseInt(card.dataset.dex || '0');
          const roll = d20() + dex;
          card.dataset.init = String(roll);
          card.querySelector('.init-value').textContent = String(roll);
        }
      }
    });
    clearManualInputs();
    sortByInitiative();
    combatStarted = true;
    round = 1;
    currentIndex = 0;
    roundNum.textContent = String(round);
    nextTurnBtn.removeAttribute('disabled');
    highlightCurrent();
  }

  function clearManualInputs() {
    manualInputsShowing = false;
    list.querySelectorAll('.manual-init-input').forEach(input => input.remove());
    list.querySelectorAll('.init-value').forEach(el => el.style.display = '');
    rollAllBtn.textContent = 'Roll All Initiative';
    rollAllBtn.classList.remove('btn-confirm');
  }

  // Roll all (or confirm manual rolls)
  rollAllBtn.addEventListener('click', () => {
    if (manualMode && !manualInputsShowing) {
      showManualInputs();
      return;
    }
    if (manualMode && manualInputsShowing) {
      confirmManualRolls();
      return;
    }
    getAllCards().forEach(card => rollInitiative(card));
    sortByInitiative();
    combatStarted = true;
    round = 1;
    currentIndex = 0;
    roundNum.textContent = String(round);
    nextTurnBtn.removeAttribute('disabled');
    highlightCurrent();
  });

  // Next turn
  nextTurnBtn.addEventListener('click', () => {
    if (!combatStarted) return;
    const cards = getAllCards();
    currentIndex++;
    if (currentIndex >= cards.length) {
      currentIndex = 0;
      round++;
      roundNum.textContent = String(round);
    }
    highlightCurrent();
  });

  // Add enemy from monster database
  function addEnemyFromMonster(mon) {
    const clone = template.content.cloneNode(true);
    const card = clone.querySelector('.init-card');
    const dexMod = Math.floor((mon.dex - 10) / 2);

    card.querySelector('.enemy-remove').addEventListener('click', () => card.remove());

    const acInput = card.querySelector('.enemy-ac');
    const hpInput = card.querySelector('.enemy-hp');
    const dexInput = card.querySelector('.enemy-dex');
    const nameInput = card.querySelector('.enemy-name-input');

    // Pre-fill with monster data
    nameInput.value = mon.n || mon.name || '';
    acInput.value = String(mon.ac);
    hpInput.value = String(mon.hp);
    dexInput.value = String(dexMod);

    card.dataset.name = nameInput.value;
    card.dataset.hp = String(mon.hp);
    card.dataset.maxHp = String(mon.hp);
    card.dataset.dex = String(dexMod);
    card.dataset.ac = String(mon.ac);

    card.querySelector('.init-hp-text').textContent = mon.hp + ' / ' + mon.hp;

    hpInput.addEventListener('change', () => {
      const hp = parseInt(hpInput.value);
      card.dataset.hp = String(hp);
      card.dataset.maxHp = String(hp);
      card.querySelector('.init-hp-text').textContent = hp + ' / ' + hp;
      card.querySelector('.init-hp-bar').style.width = '100%';
    });
    dexInput.addEventListener('change', () => {
      card.dataset.dex = dexInput.value;
    });
    nameInput.addEventListener('input', () => {
      card.dataset.name = nameInput.value;
    });

    setupHPButtons(card);
    list.appendChild(card);
  }

  // Add custom enemy (manual entry)
  addEnemyBtn.addEventListener('click', () => {
    const clone = template.content.cloneNode(true);
    const card = clone.querySelector('.init-card');

    card.querySelector('.enemy-remove').addEventListener('click', () => card.remove());

    const acInput = card.querySelector('.enemy-ac');
    const hpInput = card.querySelector('.enemy-hp');
    const dexInput = card.querySelector('.enemy-dex');
    const nameInput = card.querySelector('.enemy-name-input');

    hpInput.addEventListener('change', () => {
      const hp = parseInt(hpInput.value);
      card.dataset.hp = String(hp);
      card.dataset.maxHp = String(hp);
      card.querySelector('.init-hp-text').textContent = hp + ' / ' + hp;
      card.querySelector('.init-hp-bar').style.width = '100%';
    });
    dexInput.addEventListener('change', () => {
      card.dataset.dex = dexInput.value;
    });
    nameInput.addEventListener('input', () => {
      card.dataset.name = nameInput.value;
    });

    card.dataset.hp = '20';
    card.dataset.maxHp = '20';
    card.dataset.dex = '0';
    card.dataset.ac = '12';

    setupHPButtons(card);
    list.appendChild(card);
    nameInput.focus();
  });

  // Monster search autocomplete
  monsterSearchInput.addEventListener('input', () => {
    const query = monsterSearchInput.value.toLowerCase().trim();
    if (query.length < 2) {
      monsterSearchResults.style.display = 'none';
      return;
    }
    const matches = monsterList.filter(m => m.n.toLowerCase().includes(query)).slice(0, 12);
    if (matches.length === 0) {
      monsterSearchResults.innerHTML = '<div class="ms-item ms-empty">No monsters found</div>';
    } else {
      monsterSearchResults.innerHTML = matches.map(m =>
        '<div class="ms-item" data-slug="' + m.s + '">' +
          '<span class="ms-name">' + m.n + '</span>' +
          '<span class="ms-meta">CR ' + m.cr + ' · AC ' + m.ac + ' · HP ' + m.hp + '</span>' +
        '</div>'
      ).join('');
    }
    monsterSearchResults.style.display = '';

    monsterSearchResults.querySelectorAll('.ms-item[data-slug]').forEach(item => {
      item.addEventListener('click', () => {
        const slug = item.dataset.slug;
        const mon = monsterList.find(m => m.s === slug);
        if (mon) {
          addEnemyFromMonster(mon);
        }
        monsterSearchInput.value = '';
        monsterSearchResults.style.display = 'none';
      });
    });
  });

  document.addEventListener('click', (e) => {
    if (!monsterSearchInput.contains(e.target) && !monsterSearchResults.contains(e.target)) {
      monsterSearchResults.style.display = 'none';
    }
  });

  monsterSearchInput.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      monsterSearchResults.style.display = 'none';
      monsterSearchInput.value = '';
    }
  });

  // Reset
  resetBtn.addEventListener('click', () => {
    combatStarted = false;
    round = 0;
    currentIndex = -1;
    roundNum.textContent = '0';
    nextTurnBtn.setAttribute('disabled', '');
    if (manualInputsShowing) clearManualInputs();
    const cards = getAllCards();
    cards.forEach(card => {
      card.classList.remove('active-turn', 'downed');
      card.querySelector('.init-value').textContent = '--';
      card.dataset.init = '0';
      if (card.dataset.type === 'enemy') {
        card.remove();
      } else {
        const maxHp = parseInt(card.dataset.maxHp || '20');
        card.dataset.hp = String(maxHp);
        const bar = card.querySelector('.init-hp-bar');
        bar.style.width = '100%';
        bar.style.background = '#27ae60';
        card.querySelector('.init-hp-text').textContent = maxHp + ' / ' + maxHp;
      }
    });
  });

  // HP buttons — click: ±1, shift+click: show custom input
  function setupHPButtons(card) {
    const dmgBtn = card.querySelector('.hp-dmg');
    const healBtn = card.querySelector('.hp-heal');
    const customWrap = card.querySelector('.hp-custom-input');
    const customInput = card.querySelector('.hp-custom-val');
    const applyDmg = card.querySelector('.hp-custom-dmg');
    const applyHeal = card.querySelector('.hp-custom-heal-btn');

    let customMode = null;

    function showCustomInput(mode) {
      customMode = mode;
      customInput.value = '';
      customWrap.style.display = 'flex';
      applyDmg.style.display = mode === 'damage' ? 'flex' : 'none';
      applyHeal.style.display = mode === 'heal' ? 'flex' : 'none';
      customInput.focus();
    }

    function hideCustomInput() {
      customMode = null;
      customWrap.style.display = 'none';
      customInput.value = '';
    }

    function applyCustom() {
      const val = parseInt(customInput.value);
      if (!isNaN(val) && val > 0) {
        updateHP(card, customMode === 'damage' ? -val : val);
      }
      hideCustomInput();
    }

    dmgBtn.addEventListener('click', (e) => {
      if (e.shiftKey) {
        showCustomInput('damage');
      } else {
        hideCustomInput();
        updateHP(card, -1);
      }
    });

    healBtn.addEventListener('click', (e) => {
      if (e.shiftKey) {
        showCustomInput('heal');
      } else {
        hideCustomInput();
        updateHP(card, 1);
      }
    });

    applyDmg.addEventListener('click', applyCustom);
    applyHeal.addEventListener('click', applyCustom);

    customInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') applyCustom();
      if (e.key === 'Escape') hideCustomInput();
    });

    let pressTimer;
    dmgBtn.addEventListener('pointerdown', () => {
      pressTimer = setTimeout(() => showCustomInput('damage'), 500);
    });
    dmgBtn.addEventListener('pointerup', () => clearTimeout(pressTimer));
    dmgBtn.addEventListener('pointerleave', () => clearTimeout(pressTimer));

    healBtn.addEventListener('pointerdown', () => {
      pressTimer = setTimeout(() => showCustomInput('heal'), 500);
    });
    healBtn.addEventListener('pointerup', () => clearTimeout(pressTimer));
    healBtn.addEventListener('pointerleave', () => clearTimeout(pressTimer));
  }

  getAllCards().forEach(card => setupHPButtons(card));

  // Pick up pending enemies from localStorage (from Encounter Planner or Monster detail pages)
  try {
    const pending = JSON.parse(localStorage.getItem('sbtf-pending-enemies') || '[]');
    if (pending.length > 0) {
      pending.forEach(enemy => {
        addEnemyFromMonster({
          n: enemy.name,
          ac: parseInt(enemy.ac) || 12,
          hp: parseInt(enemy.hp) || 20,
          dex: (parseInt(enemy.dex) || 0) * 2 + 10, // convert mod back to score for addEnemyFromMonster
        });
      });
      localStorage.removeItem('sbtf-pending-enemies');
    }
  } catch(e) { /* ignore parse errors */ }
</script>

<style>
.back-link { margin-bottom: 1.5rem; }
.back-link a { color: var(--text-muted); font-size: 0.85rem; }
.back-link a:hover { color: var(--accent-primary); }
.intro-text { color: var(--text-muted); font-size: 0.9rem; margin-bottom: 1.5rem; }

/* Controls */
.controls {
  display: flex; align-items: center; gap: 0.75rem;
  flex-wrap: wrap; margin-bottom: 1.5rem;
}
.btn {
  padding: 0.5rem 1rem; border: 1px solid; border-radius: 6px;
  font-size: 0.85rem; font-weight: bold; cursor: pointer;
  transition: all 0.2s;
}
.btn:disabled { opacity: 0.4; cursor: not-allowed; }
.btn-primary { background: rgba(0,201,167,0.2); border-color: var(--border-accent); color: var(--accent-primary); }
.btn-primary:hover:not(:disabled) { background: rgba(0,201,167,0.35); }
.btn-secondary { background: rgba(100,100,100,0.15); border-color: rgba(100,100,100,0.3); color: var(--text-normal); }
.btn-secondary:hover { background: rgba(100,100,100,0.25); }
.btn-accent { background: rgba(39,174,96,0.15); border-color: rgba(39,174,96,0.4); color: #6ec97a; }
.btn-accent:hover:not(:disabled) { background: rgba(39,174,96,0.3); }
.btn-muted { background: rgba(100,100,100,0.08); border-color: rgba(100,100,100,0.2); color: var(--text-muted); }
.btn-muted:hover { background: rgba(100,100,100,0.15); }

.manual-toggle.manual-active {
  background: rgba(0,201,167,0.25); border-color: var(--border-accent); color: var(--accent-primary);
}
.btn-confirm {
  background: rgba(39,174,96,0.2) !important; border-color: rgba(39,174,96,0.5) !important;
  color: #6ec97a !important;
}
.btn-confirm:hover { background: rgba(39,174,96,0.35) !important; }
.manual-init-input {
  width: 40px; padding: 0.2rem; text-align: center; font-size: 1.2rem; font-weight: bold;
  background: rgba(100,100,100,0.2); border: 1px solid rgba(0,201,167,0.5);
  color: var(--accent-primary); border-radius: 4px;
  -moz-appearance: textfield;
}
.manual-init-input::-webkit-outer-spin-button,
.manual-init-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.manual-init-input:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 6px rgba(0,201,167,0.4); }

.round-display {
  margin-left: auto; font-size: 0.85rem; color: var(--text-muted);
  background: rgba(0,201,167,0.08); border: 1px solid rgba(0,201,167,0.2);
  padding: 0.4rem 0.9rem; border-radius: 6px;
}
.round-display span { color: var(--accent-primary); font-weight: bold; font-size: 1.1rem; }

/* Initiative list */
.initiative-list { display: flex; flex-direction: column; gap: 0.5rem; }

.init-card {
  display: flex; align-items: center; gap: 0.75rem;
  padding: 0.75rem 1rem;
  background: var(--card-bg);
  border: 1px solid var(--border-card);
  border-left: 4px solid var(--card-color, var(--accent-primary-dim));
  border-radius: 8px;
  transition: all 0.3s;
}
.init-card.active-turn {
  border-color: var(--card-color, var(--accent-primary-dim));
  background: rgba(0,201,167,0.12);
  box-shadow: 0 0 15px rgba(0,201,167,0.2);
}
.init-card.downed { opacity: 0.4; }

.init-roll {
  display: flex; flex-direction: column; align-items: center;
  min-width: 44px; flex-shrink: 0;
}
.init-value { font-size: 1.6rem; font-weight: bold; color: var(--accent-primary); line-height: 1; }
.init-label { font-size: 0.55rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); }

.init-portrait {
  width: 40px; height: 40px; border-radius: 50%;
  border: 2px solid var(--card-color, var(--accent-primary-dim));
  flex-shrink: 0; object-fit: cover;
}

.init-info { flex: 1; min-width: 0; }
.init-name { font-size: 0.95rem; font-weight: bold; color: var(--accent-primary); }
.init-sub { font-size: 0.72rem; color: var(--text-muted); }

.init-hp-block { min-width: 100px; }
.init-hp-bar-wrap {
  height: 6px; background: rgba(100,100,100,0.2); border-radius: 3px;
  overflow: hidden; margin-bottom: 0.2rem;
}
.init-hp-bar { height: 100%; background: #27ae60; border-radius: 3px; transition: width 0.3s; }
.init-hp-text { font-size: 0.7rem; color: var(--text-muted); text-align: center; }

.init-actions { display: flex; gap: 0.3rem; flex-shrink: 0; }
.hp-btn {
  width: 28px; height: 28px; border-radius: 50%; border: 1px solid;
  font-size: 1rem; font-weight: bold; cursor: pointer; line-height: 1;
  display: flex; align-items: center; justify-content: center;
}
.hp-dmg { background: rgba(192,57,43,0.15); border-color: rgba(192,57,43,0.4); color: #e74c3c; }
.hp-dmg:hover { background: rgba(192,57,43,0.3); }
.hp-heal { background: rgba(39,174,96,0.15); border-color: rgba(39,174,96,0.4); color: #27ae60; }
.hp-heal:hover { background: rgba(39,174,96,0.3); }

/* Custom HP input */
.hp-custom-input {
  display: none; align-items: center; gap: 0.2rem;
}
.hp-custom-val {
  width: 48px; padding: 0.15rem 0.3rem; text-align: center;
  background: rgba(100,100,100,0.2); border: 1px solid rgba(0,201,167,0.4);
  color: var(--text-normal); border-radius: 4px; font-size: 0.8rem;
  -moz-appearance: textfield;
}
.hp-custom-val::-webkit-outer-spin-button,
.hp-custom-val::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.hp-custom-apply {
  width: 24px; height: 24px; border-radius: 4px; border: 1px solid;
  font-size: 0.75rem; cursor: pointer; display: flex;
  align-items: center; justify-content: center; line-height: 1;
}
.hp-custom-dmg { background: rgba(192,57,43,0.2); border-color: rgba(192,57,43,0.4); color: #e74c3c; }
.hp-custom-dmg:hover { background: rgba(192,57,43,0.35); }
.hp-custom-heal-btn { background: rgba(39,174,96,0.2); border-color: rgba(39,174,96,0.4); color: #27ae60; }
.hp-custom-heal-btn:hover { background: rgba(39,174,96,0.35); }

/* Enemy cards */
.enemy-name-input {
  background: transparent; border: none; border-bottom: 1px solid rgba(0,201,167,0.3);
  color: var(--accent-primary); font-size: 0.95rem; font-weight: bold;
  padding: 0.2rem 0; width: 100%; outline: none;
}
.enemy-name-input:focus { border-color: var(--border-accent); }
.enemy-fields {
  display: flex; align-items: center; gap: 0.5rem; margin-top: 0.3rem;
  font-size: 0.72rem; color: var(--text-muted);
}
.enemy-fields input {
  width: 40px; background: rgba(100,100,100,0.15); border: 1px solid rgba(100,100,100,0.3);
  color: var(--text-normal); border-radius: 3px; padding: 0.15rem 0.3rem;
  font-size: 0.75rem; text-align: center;
}
.enemy-remove {
  background: rgba(192,57,43,0.15); border: 1px solid rgba(192,57,43,0.3);
  color: #e74c3c; border-radius: 3px; cursor: pointer;
  font-size: 1rem; padding: 0 0.4rem; line-height: 1.2;
}
.enemy-remove:hover { background: rgba(192,57,43,0.3); }

/* Monster search */
.monster-search-wrap {
  position: relative;
  min-width: 200px;
}
.monster-search-wrap input {
  width: 100%;
  padding: 0.4rem 0.6rem;
  font-size: 0.82rem;
  background: rgba(0,0,0,0.3);
  border: 1px solid rgba(0,201,167,0.3);
  border-radius: 6px;
  color: var(--text-normal);
}
.monster-search-wrap input:focus { outline: none; border-color: var(--accent-primary); }
.monster-search-results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  z-index: 50;
  background: #0d1b2a;
  border: 1px solid rgba(0,201,167,0.3);
  border-top: none;
  border-radius: 0 0 6px 6px;
  max-height: 250px;
  overflow-y: auto;
}
.ms-item {
  padding: 0.45rem 0.6rem;
  cursor: pointer;
  transition: background 0.1s;
  border-bottom: 1px solid rgba(100,100,100,0.1);
}
.ms-item:hover { background: rgba(0,201,167,0.12); }
.ms-item.ms-empty { cursor: default; color: var(--text-muted); font-style: italic; font-size: 0.82rem; }
.ms-name { display: block; font-size: 0.82rem; font-weight: 600; color: var(--text-normal); }
.ms-meta { display: block; font-size: 0.68rem; color: var(--text-muted); }

@media (max-width: 640px) {
  .init-card { flex-wrap: wrap; gap: 0.5rem; }
  .init-portrait { width: 32px; height: 32px; }
  .init-hp-block { width: 100%; order: 10; }
  .controls { gap: 0.5rem; }
  .btn { padding: 0.4rem 0.75rem; font-size: 0.78rem; }
  .monster-search-wrap { min-width: auto; width: 100%; order: -1; }
}
</style>
